

<!-- TOC -->

- [1. 回溯](#1-回溯)
    - [1.1. 什么是回溯？](#11-什么是回溯)
    - [1.2. 回溯法能解决的问题](#12-回溯法能解决的问题)
    - [1.3. 回溯法模板](#13-回溯法模板)

<!-- /TOC -->


# 1. 回溯


<!-- 
揭秘回溯算法 
https://mp.weixin.qq.com/s/yH6cLfOBjMJdbprdo3c4mg
五大常用算法之四：回溯法
https://blog.csdn.net/qfikh/article/details/51960331 

-->
<!-- 

回溯法视频
https://www.bilibili.com/video/BV1cy4y167mM
-->


## 1.1. 什么是回溯？  


&emsp; 回溯和递归的区别： 
<!-- 
回溯和递归的区别（简述）
https://blog.csdn.net/weixin_46523794/article/details/111121405
--> 

&emsp; 回溯与DFS：  
<!-- 

回溯法与深度优先遍历的异同
https://blog.csdn.net/gardenpalace/article/details/84625537
-->


<!-- 


递归、回溯、DFS和BFS总结
https://blog.csdn.net/u014303647/article/details/88328526
-->

---------
&emsp; 面对这种需要列出所有可能性的问题，很容易想到的就是使用回溯的方法来解决，分析问题，首先需要把一个复杂的问题分解成相对来说较为简单的子问题，然后将这个子问题的解进行组合就可以找到复杂问题的解了。  

&emsp; 因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，如果想让回溯法⾼效⼀些，可以加⼀些剪枝的操作，但也改不了回溯法就是穷举的本质。  

回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。  


回溯法确实不好理解，所以需要把回溯法抽象为⼀个图形来理解就容易多了，每⼀道回溯法的题⽬都可以抽象为树形结构。  
把回溯问题抽象为树形结构，可以直观的看出其搜索的过程：for循环横向遍历，递归纵向遍历，回溯不断调整结果集。  
剪枝精髓是：for循环在寻找起点的时候要有⼀个范围，如果这个起点到集合终⽌之间的元素已经不够题⽬要求的k个元素了，就没有必要搜索了。  

回溯也是一种暴力搜索，有些for循环不是那么好写。  



## 1.2. 回溯法能解决的问题

&emsp; 回溯法，⼀般可以解决如下⼏种问题：  

* 组合问题：N个数⾥⾯按⼀定规则找出k个数的集合
* 排列问题：N个数按⼀定规则全排列，有⼏种排列⽅式
* 切割问题：⼀个字符串按⼀定规则有⼏种切割⽅式
* ⼦集问题：⼀个N个数的集合⾥有多少符合条件的⼦集
* 棋盘问题：N皇后，解数独等等


&emsp; 回溯法解决的问题都可以抽象为树形结构，是的，我指的是所有回溯法的问题都可以抽象为树形结构！  
&emsp; 因为回溯法解决的都是在集合中递归查找⼦集， 集合的⼤⼩就构成了树的宽度，递归的深度，都构成的
树的深度。  
&emsp; 递归就要有终⽌条件，所以必然是⼀颗⾼度有限的树（N叉树）。  


## 1.3. 回溯法模板

<!-- 
https://www.cnblogs.com/dreamyu/p/13210713.html
-->

```text
void backtracking(参数) {
    
    if(不满足条件){  // todo 剪枝
        return;
    }

    if (终⽌条件) {
        存放结果;
        return;
    }
    for (选择：本层集合中元素（树中节点孩⼦的数量就是集合的⼤⼩） ) {  //todo 剪枝要修改的地方
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

```text
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
​
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```

```text
for 选择 in 选择列表:
    # 做选择
    将该选择从选择列表移除
    路径.add(选择)
    backtrack(路径, 选择列表)
    # 撤销选择
    路径.remove(选择)
    将该选择再加入选择列表
```

其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」。  


-------------
非递归回溯框架  

```text
: int a[n],i;
: 初始化数组a[];
: i = 1;
: while (i>0(有路可走)   and  (未达到目标))  // 还未回溯到头
: {
:     if(i > n)                                              // 搜索到叶结点
:     {
:           搜索到一个解，输出；
:     }
:     else                                                   // 处理第i个元素
:     {
:           a[i]第一个可能的值；
:           while(a[i]在不满足约束条件且在搜索空间内)
:           {
:               a[i]下一个可能的值；
:           }
:           if(a[i]在搜索空间内)
:          {
:               标识占用的资源；
:               i = i+1;                              // 扩展下一个结点
:          }
:          else
:         {
:               清理所占的状态空间；            // 回溯
:               i = i –1;
:          }
: }
```

递归的算法框架  
回溯法是对解空间的深度优先搜索，在一般情况下使用递归函数来实现回溯法比较简单，其中i为搜索的深度，框架如下：  

```text
: int a[n];
: try(int i)
: {
:     if(i>n)
:        输出结果;
:      else
:     {
:        for(j = 下界; j <= 上界; j=j+1)  // 枚举i所有可能的路径
:        {
:            if(fun(j))                 // 满足限界函数和约束条件
:              {
:                 a[i] = j;
:               ...                         // 其他操作
:                 try(i+1);
:               回溯前的清理工作（如a[i]置空值等）;
:               }
:          }
:      }
: }
```


-----
不可重复回溯与可重复回溯：只是for循环的下界不同。  
<!-- 
https://www.cnblogs.com/oldhands/p/11840667.html
-->