


# 回溯
<!--

回溯和递归的区别（简述）
https://blog.csdn.net/weixin_46523794/article/details/111121405
回溯法模板
https://zhuanlan.zhihu.com/p/138587283

回溯算法套路详解（转）
https://www.cnblogs.com/dreamyu/p/13210713.html

回溯法视频
https://www.bilibili.com/video/BV1cy4y167mM

回溯法模板
https://www.cnblogs.com/hygeia/p/5812128.html
https://zhuanlan.zhihu.com/p/138587283
https://www.cnblogs.com/oldhands/p/11840667.html

https://blog.csdn.net/u014303647/article/details/88328526
-->
回溯法确实不好理解，所以需要把回溯法抽象为⼀个图形来理解就容易多了，每⼀道回溯法的题⽬都可以抽象为树形结构。  
把回溯问题抽象为树形结构，可以直观的看出其搜索的过程：for循环横向遍历，递归纵向遍历，回溯不断调整结果集。  
剪枝精髓是：for循环在寻找起点的时候要有⼀个范围，如果这个起点到集合终⽌之间的元素已经不够题⽬要求的k个元素了，就没有必要搜索了。  

回溯也是一种暴力搜索，有些for循环不是那么好写。  

## 回溯和递归的区别

&emsp; 面对这种需要列出所有可能性的问题，很容易想到的就是使用回溯的方法来解决，分析问题，首先需要把一个复杂的问题分解成相对来说较为简单的子问题，然后将这个子问题的解进行组合就可以找到复杂问题的解了。  

&emsp; 因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，如果想让回溯法⾼效⼀些，可以加
⼀些剪枝的操作，但也改不了回溯法就是穷举的本质。  

回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。  


## 回溯法能解决的问题

&emsp; 回溯法，⼀般可以解决如下⼏种问题：  

* 组合问题：N个数⾥⾯按⼀定规则找出k个数的集合
* 排列问题：N个数按⼀定规则全排列，有⼏种排列⽅式
* 切割问题：⼀个字符串按⼀定规则有⼏种切割⽅式
* ⼦集问题：⼀个N个数的集合⾥有多少符合条件的⼦集
* 棋盘问题：N皇后，解数独等等


&emsp; 回溯法解决的问题都可以抽象为树形结构，是的，我指的是所有回溯法的问题都可以抽象为树形结构！  
&emsp; 因为回溯法解决的都是在集合中递归查找⼦集， 集合的⼤⼩就构成了树的宽度，递归的深度，都构成的
树的深度。  
&emsp; 递归就要有终⽌条件，所以必然是⼀颗⾼度有限的树（N叉树）。  


## 回溯法模板

<!-- 

https://zhuanlan.zhihu.com/p/138587283
-->

```text
void backtracking(参数) {
    
    if(不满足条件){  // todo 剪枝
        return;
    }

    if (终⽌条件) {
        存放结果;
        return;
    }
    for (选择：本层集合中元素（树中节点孩⼦的数量就是集合的⼤⼩） ) {  //todo 剪枝要修改的地方
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```