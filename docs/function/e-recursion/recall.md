

<!-- TOC -->

- [1. 回溯](#1-回溯)
    - [1.1. 什么是回溯？](#11-什么是回溯)
        - [1.1.1. 回溯](#111-回溯)
        - [1.1.2. 回溯 + 剪枝](#112-回溯--剪枝)
    - [1.2. 回溯法能解决的问题](#12-回溯法能解决的问题)
    - [1.3. 回溯法模板](#13-回溯法模板)
        - [1.3.1. 无重复输入](#131-无重复输入)
            - [1.3.1.1. 递归](#1311-递归)
            - [1.3.1.2. 迭代](#1312-迭代)
        - [1.3.2. 有重复输入](#132-有重复输入)

<!-- /TOC -->


# 1. 回溯


<!-- 

labuladong
https://labuladong.gitbook.io/algo/mu-lu-ye-3/mu-lu-ye/hui-su-suan-fa-xiang-jie-xiu-ding-ban

-->
<!-- ~~

https://mp.weixin.qq.com/s/gMMnZC0KvKee1V16lJzPKg
https://programmercarl.com/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html
回溯法视频
https://www.bilibili.com/video/BV1cy4y167mM
-->


&emsp; 参考【代码随想录】、【西法的刷题秘籍】...  

## 1.1. 什么是回溯？  

### 1.1.1. 回溯
&emsp; 回溯和递归的区别： 
<!-- 
回溯和递归的区别（简述）
https://blog.csdn.net/weixin_46523794/article/details/111121405
--> 

&emsp; 回溯与DFS：  
<!-- 

回溯法与深度优先遍历的异同
https://blog.csdn.net/gardenpalace/article/details/84625537
-->


<!-- 


递归、回溯、DFS和BFS总结
https://blog.csdn.net/u014303647/article/details/88328526
-->

---------
&emsp; 面对需要列出所有可能性的问题，很容易想到的就是使用回溯的方法来解决，分析问题，首先需要把一个复杂的问题分解成相对来说较为简单的子问题，然后将这个子问题的解进行组合就可以找到复杂问题的解了。  
&emsp; 因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，如果想让回溯法⾼效⼀些，可以加⼀些剪枝的操作，但也改不了回溯法就是穷举的本质。  

回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。  


回溯法确实不好理解，所以需要把回溯法抽象为⼀个图形来理解就容易多了，每⼀道回溯法的题⽬都可以抽象为树形结构。  
把回溯问题抽象为树形结构，可以直观的看出其搜索的过程：for循环横向遍历，递归纵向遍历，回溯不断调整结果集。  
剪枝精髓是：for循环在寻找起点的时候要有⼀个范围，如果这个起点到集合终⽌之间的元素已经不够题⽬要求的k个元素了，就没有必要搜索了。  

回溯也是一种暴力搜索，有些for循环不是那么好写。  

-------
《西法的刷题秘籍》第315页
回溯是 DFS 中的⼀种技巧。回溯法采⽤ 试错 的思想，它尝试分步的去解 决⼀个问题。在分步解决问题的过程中，当它通过尝试发现现有的分步答 案不能得到有效的正确的解答的时候，它将取消上⼀步甚⾄是上⼏步的计 算，再通过其它的可能的分步解答再次尝试寻找问题的答案。  
通俗上讲，回溯是⼀种⾛不通就回头的算法。  
回溯的本质是穷举所有可能，尽管有时候可以通过剪枝去除⼀些根本不可 能是答案的分⽀， 但是从本质上讲，仍然是⼀种暴⼒枚举算法。  
回溯法可以抽象为树形结构，并且是是⼀颗⾼度有限的树（N 叉树）。回溯法解决的都是在集合中查找⼦集，集合的⼤⼩就是树的叉树，递归的深 度，构成树的⾼度。  


### 1.1.2. 回溯 + 剪枝
&emsp; 【西法的刷题秘籍】  


## 1.2. 回溯法能解决的问题

&emsp; 回溯法，⼀般可以解决如下⼏种问题：  

* 组合问题：N个数⾥⾯按⼀定规则找出k个数的集合
* 排列问题：N个数按⼀定规则全排列，有⼏种排列⽅式
* 切割问题：⼀个字符串按⼀定规则有⼏种切割⽅式
* ⼦集问题：⼀个N个数的集合⾥有多少符合条件的⼦集
* 棋盘问题：N皇后，解数独等等


&emsp; 回溯法解决的问题都可以抽象为树形结构，是的，我指的是所有回溯法的问题都可以抽象为树形结构！  
&emsp; 因为回溯法解决的都是在集合中递归查找⼦集， 集合的⼤⼩就构成了树的宽度，递归的深度，都构成的
树的深度。  
&emsp; 递归就要有终⽌条件，所以必然是⼀颗⾼度有限的树（N叉树）。  


## 回溯算法三部曲
<!-- 
https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html#%E5%9B%9E%E6%BA%AF%E6%B3%95%E4%B8%89%E9%83%A8%E6%9B%B2
-->

## 1.3. 回溯法模板
![image](https://gitee.com/wt1814/pic-host/raw/master/algorithm/function-62.png)

<!-- 
揭秘回溯算法 
https://mp.weixin.qq.com/s/yH6cLfOBjMJdbprdo3c4mg
回溯法模版
https://mp.weixin.qq.com/s/trILKSiN9EoS58pXmvUtUQ
https://labuladong.gitbook.io/algo/mu-lu-ye/hui-su-suan-fa-xiang-jie-xiu-ding-ban

-->

<!-- 
https://www.cnblogs.com/dreamyu/p/13210713.html
-->


### 1.3.1. 无重复输入
<!-- 
https://www.cnblogs.com/oldhands/p/11840667.html
-->

#### 1.3.1.1. 递归

```text
    List<Object> result = new ArrayList<>();

    void backtracking(参数) {

        if(不满足条件){  // todo 剪枝
            return;
        }

        if (终⽌条件) {
            result.add(结果)  // todo 存放结果
            return;
        }
        for (选择：本层集合中元素（树中节点孩⼦的数量就是集合的⼤⼩） ) {  //todo 剪枝要修改的地方
            
            if (可选解在已选择的集合中) { 
                continue; 
            }
            
            // todo 处理节点; 做选择
            将该选择从选择列表移除;
            路径.add(选择);
            
            backtracking(路径，选择列表); // 递归
            
            //todo 撤销选择   回溯，撤销处理结果
            路径.remove(选择)
            将该选择再加入选择列表
        }
    }
```

-------------------

```text
void back_trace(已选择的集合，当前解的状态，可选择的解的集合) {
    if (当前解满足条件) {
        结果集.add(当前解);
        return;
    }
    for (可选解 : 可选择的解的集合) {
        if (可选解在已选择的集合中) { continue; }
        已选择集合.add(可选解);
        当前解的状态.add(可选解);
        back_trace(已选择的集合，当前解状态，下个可选择的集合);
        已选择的集合.remove(可选解);
        当前解的状态.remove(可选解);
    }
}
```

------------------------------------

```text
void backtracking(参数) {
    
    if(不满足条件){  // todo 剪枝
        return;
    }

    if (终⽌条件) {
        存放结果;
        return;
    }
    for (选择：本层集合中元素（树中节点孩⼦的数量就是集合的⼤⼩） ) {  //todo 剪枝要修改的地方
        处理节点; // 做选择
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果  // 撤销选择
    }
}
```

```text
for 选择 in 选择列表:
    # 做选择
    将该选择从选择列表移除
    路径.add(选择)
    backtrack(路径, 选择列表)
    # 撤销选择
    路径.remove(选择)
    将该选择再加入选择列表
```

其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」。



递归的算法框架  
回溯法是对解空间的深度优先搜索，在一般情况下使用递归函数来实现回溯法比较简单，其中i为搜索的深度，框架如下：

```text
: int a[n];
: try(int i)
: {
:     if(i>n)
:        输出结果;
:      else
:     {
:        for(j = 下界; j <= 上界; j=j+1)  // 枚举i所有可能的路径
:        {
:            if(fun(j))                 // 满足限界函数和约束条件
:              {
:                 a[i] = j;
:               ...                         // 其他操作
:                 try(i+1);
:               回溯前的清理工作（如a[i]置空值等）;
:               }
:          }
:      }
: }
```

<!-- 

```text
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
​
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
```
-->


#### 1.3.1.2. ~~迭代~~

非递归回溯框架

```text
: int a[n],i;
: 初始化数组a[];
: i = 1;
: while (i>0(有路可走)   and  (未达到目标))  // 还未回溯到头
: {
:     if(i > n)                                              // 搜索到叶结点
:     {
:           搜索到一个解，输出；
:     }
:     else                                                   // 处理第i个元素
:     {
:           a[i]第一个可能的值；
:           while(a[i]在不满足约束条件且在搜索空间内)
:           {
:               a[i]下一个可能的值；
:           }
:           if(a[i]在搜索空间内)
:          {
:               标识占用的资源；
:               i = i+1;                              // 扩展下一个结点
:          }
:          else
:         {
:               清理所占的状态空间；            // 回溯
:               i = i –1;
:          }
: }
```

### 1.3.2. 有重复输入  
&emsp; 以上是针对无重复的输入的排列，但对于有重复的输入，使用套路1就有一点点小问题，对于这种情况，可以使用这种套路2。  


<!-- 
https://mp.weixin.qq.com/s/yH6cLfOBjMJdbprdo3c4mg
-->

```text
void main() {
    首先对输入的数组排序，使相同的元素在相邻的位置
    back_trace();
}

void back_trace(已选择的集合，当前解的状态，可选择的解的集合) {
    if (当前解满足条件) {
        结果集.add(当前解);
        return;
    }
    for (可选解 : 可选择的解的集合) {
        if (当前可选解和上一可选解相同&&上一可选解未在已选择集合里) {  // todo
            continue; 
        }
        if (可选解在已选择的集合中) { 
            continue; 
        }
        已选择集合.add(可选解);
        当前解的状态.add(可选解);
        back_trace(已选择的集合，当前解状态，下个可选择的集合);
        已选择的集合.remove(可选解);
        当前解的状态.remove(可选解);
    }
}
```

